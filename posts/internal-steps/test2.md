---
title: 웹브라우저에서 검색할 때 어떤 일이 벌어지나?
category: computer structure
date: 2020-12-30T22:50:12.715Z
---

# 웹브라우저에서 일어나는 일들

어디서 듣기로, 기업에 입사할 때 이런 문제를 묻는 경우가 있다고 합니다.

> 웹 브라우저의 주소창에 http://google.com을 입력한 후 엔터를 누른다.
> 이후 웹 페이지가 표시될 때까지 일어나는 일을 아는 대로 설명해라.

저도 컴퓨터를 전공하면서 이런 것을 얼마나 상세히 대답할 수 있는지 궁금해져서 한 번 정리해보기로 했습니다.

아래 내용은 모두 UNIX/Linux 계열 운영체제를 기반으로 설명합니다.

## 하드웨어에서

먼저 키보드의 키가 눌리면, 내부의 스위치가 회로를 단락시킵니다. 그러면 하드웨어적으로 제작된 키보드 모듈에서 이를 감지하고 신호를 적절한 키코드로 인코딩하여 USB모듈로 전송합니다. 그러면 USB모듈에서는 USB 프로토콜에 따라 이 정보를 컴퓨터로 보냅니다.

- 아직 공부가 부족하여 키보드 모듈-키보드 내장 USB모듈 사이의 통신 프로토콜은 모릅니다.
- USB에 대해서도 상세히 알지 못하여(USB프로토콜은 I2C나 UART등과 다르게 매우 복잡합니다) 컴퓨터로 전송되는 과정은 설명하지 못하겠습니다.

그러면 컴퓨터에서는 USB신호를 받습니다. 이 신호는 컴퓨터의 USB모듈을 통해 수신되며, 이 모듈은 이를 적절한 신호로 디코딩하여 CPU로 보내게 됩니다. 컴퓨터의 종류에 따라 이 과정은 다릅니다. 예컨대 우리가 사용하는 컴퓨터는 CPU가 아마도 North bridge나 South bridge등 bridge모듈을 통과하여 CPU에 연결되겠지만, 라즈바리파이나 모바일 기기 등은 System on Chip(SoC)라고 하여, 이런 기기들이 모두 프로세서 내부에 내장되어있습니다.

그러면 CPU에서는 하드웨어적으로 인터럽트가 발생합니다. 이때 CPU에서는 여러 인터럽트 우선순위가 있어서, 동시에 다른 인터럽트가 발생할 경우 CPU는 이를 잘 핸들링해줍니다. 제가 주로 사용하는 STM32F4 칩에는 [Nested Vector Interrupt Controller(NVIC)](https://stm32f4-discovery.net/2014/05/stm32f4-stm32f429-nvic-or-nested-vector-interrupt-controller/)라는 인터럽트 컨트롤러가 있어, 이것이 하드웨어적으로 인터럽트의 우선순위를 제어합니다. 예를 들어 context change는 일반적으로 인터럽트에 의해 구현되는데, 이는 키보드 인터럽트보다 우선순위가 낮게 설정될 수 있습니다. 그런 경우 context change와 키보드 입력이 동시 발생 시 키보드를 먼저 처리한 후 context change가 일어납니다. 어쨌든 이제 인터럽트가 발생하였으므로 CPU는 인터럽트를 처리해야합니다. 이를 위해 현재 CPU의 레지스터 정보를 다른 곳에 저장한 후, 인터럽트 처리를 해 줍니다.

## 커널에서

컴퓨터에서는 애초에 CPU에 미리 인터럽트 핸들러를 등록해놓습니다. 이는 커널 모듈 드라이버에 의해 이루어집니다. (키보드 커널 모듈 드라이버는 이미 로드되어있다고 가정하겠습니다.) CPU는 그러면 그 인터럽트 핸들러 함수를 실행합니다. 이 인터럽트는 굉장히 빨리 처리되어야 하므로, 내부적으로 커널 메모리 공간에 선언된 작은 버퍼에 입력된 키 정보를 집어넣은 후, 대기 큐에 들어있는 event를 wake up 시킵니다. 이때 키보드 정보를 가져오는 것은 memory mapped I/O를 통해 이루어집니다. 이는 메모리 공간의 주소 일부가 레지스터와 연관되어있는 것인데, 따라서 키보드 정보가 저장된 레지스터를 마치 메모리처럼 접근할 수 있습니다.

이후 인터럽트가 안전하게 끝나면 이제 대기 큐에 미리 정의돼있었던 이벤트가 동작합니다. 커널에서는 적절한 데이터 처리를 거친 후, 특수한 커널 함수(copy_to_user)를 사용하여 키 정보를 유저 메모리로 복사합니다. 이는 커널 메모리는 실제 물리적 메모리 주소를 사용하는 반면, 유저 메모리는 페이징에 의해 이루어지는 가상 메모리 주소를 사용하므로 바로 복사가 불가능하기 때문입니다. 그리고 커널이 반환하면 이제 유저 프로세스가 다시 실행됩니다.

- 이것은 제가 아는 선에서 작성한 것으로 실제로는 bottom halves, tasklet, soft irq등 더 복잡한 인터럽트 스케줄링이 사용될 수 있습니다.

## 유저 프로세스에서

유저 프로세서에서는 키 값을 통하여 이 키가 엔터라는 것을 인지하고 작업을 시작합니다. 추후 이루어질 작업은 시간을 꽤 요구하기 때문에, UX를 방해하지 않기 위해 스레드를 만들어 스레드에서 작업이 이루어집니다. UNIX운영체제에서 스레드는 사실 주소 공간을 공유하는 다른 프로세스에 불과해서, 실제로는 프로세스가 하나 만들어진다고 봐도 되겠습니다.

이렇게 만들어진 스레드에서는 주소창에 입력된 주소를 분석하여 그 주소가 `google.com`이고 프로토콜이 `http`임을 알게 됩니다. 그러면 브라우저에서는 적절한 http패킷을 구성하는데, 이 패킷에는 요청한 주소, 요청하는 파일, 브라우저 정보, 쿠키 등 다양한 정보가 담겨 있습니다.

이때 만약 컴퓨터가 DNS정보를 미리 알아서, `google.com`의 IP address를 알고 있다면 그리로 패킷을 송신합니다. 그러나 `DNS`정보를 모르는 경우 `DNS`쿼리를 통해 해당 도메인과 연결된 IP를 알아 내야 합니다.

- 이것도 아직 어떤 프로토콜을 통해 이루어지는지는 잘 모르겠습니다.
- DNS쿼리가 어플리케이션 레벨에서 이루어지는 건지, 아니면 그 아래 OS에서 이루어지는 건지, 그것도 아니면 네트워크 카드에서 이루어지는것인지도 잘 모르겠습니다.

## 네트워크에서

어쨌든 이렇게 구성된 패킷은 TCP/IP 방식을 따라 전송됩니다. 아까 위에서 보았던 키보드 읽기의 반대 과정을 통하여, 구성된 패킷은 커널을 통해 네트워크 카드에 전달됩니다. 이때 네트워크 카드에서는 받은 패킷을 잘 인코딩하여 프레임으로 만듭니다. 패킷에는 IP주소 등 4계층 이상의 데이터가 들어있고, 프레임에는 MAC address나 checksum등 3계층~2계층까지의 정보가 들어있습니다.

이렇게 만들어진 프레임은 다시 하드웨어를 통해 라우터로 전송됩니다. 만약 라우터가 유선으로 직결되어있다면 라우터로 패킷을 바로 전송할 수 있습니다. 그러나 무선랜 등 다른 매체의 간섭이 있을 경우 다양한 충돌 대비 매커니즘이 사용됩니다. 제가 알기로는 무선 랜에서는 Carrier Sense Multiple Access / Collision Avoidance (CSMA/CA) 기법을 사용합니다. 이 경우 먼저 다른 디바이스들에게 프레임을 전송할 것임을 알리고(Request to Send, RTS), 이후 목적 디바이스가 프레임을 수신할 수 있다고 다시 알려주면 (Clear to Send, CTS) 미리 정해진 시간동안 독점적으로 carrier를 사용하며 데이터 전송이 이루어집니다. Ethernet의 경우 CSMA/CD기법을 사용하며, 이 경우 carrier를 사용하는 디바이스가 없을 경우 데이터를 전송합니다.

그런데 이 두 케이스 모두 한 번에 전송할 수 있는 데이터 양에 한계가 있습니다. IEEE 802.3 Ethernet 프로토콜에 따르면 최소 전송 가능한 데이터는 (프레임 전체로 따졌을 때) 64byte, 최대 전송 가능한 데이터는 1518byte입니다. 최소 데이터는 CSMA/CD의 효율적인 전송을 위해 필요하며, 최대 전송 가능한 데이터는 carrier의 무기한 독점을 막기 위해 필요합니다.

이는 우리가 일반적으로 전송하기를 원하는 수 킬로바이트에서 수 메가바이트의 데이터에 비해 턱없이 부족한 길이입니다. 따라서 데이터는 여러 조각으로 나누어져 전송되며, 수신측에서 순서를 고려하여 합칩니다. 여기에는 Sliding window를 사용하는 Automatic Repeat Request (ARQ)등의 방식이 사용됩니다.

라우터에서는 프레임을 받으면 순서대로 버퍼에 넣어두었다가 하나씩 꺼내어 처리합니다. 프레임을 꺼낸 후에는 다시 디코드하여 IP주소를 확인하고, 이후 IP주소에 맞는 다른 포트로 프레임을 다시 내보냅니다. 이 과정에서 3계층 정보는 그대로 유지되지만, 2계층 정보는 매 hop마다 바뀝니다.

이렇게 라우터를 여러 번 거친 후, 구글 서버에 도착하게 됩니다.

## 서버에서

서버에서는 보낼 때 했던 방식의 정확히 반대 방식으로 패킷을 받습니다. 패킷에는 원하는 데이터가 무엇인지 적혀있으므로 서버는 해당하는 데이터를 보내줍니다. 이 경우에는 구글 웹 사이트의 html파일이 됩니다. 물론 이 과정에서 서버에서는 키보드 입력과 비슷하게 커널을 통한 파일시스템 접근, 네트워크 카드 접근 등이 이루어집니다. 이 경우에는 앞서 말한 키보드와 다르게 블록 디바이스 드라이버가 사용됩니다.

- 그런데 알려진 바에 따르면 구글에서는 SSD나 HDD등 일반적인 보조기억장치 대신 RAM DISK라는 신기한 장치를 사용한다고 합니다. 그래서 커널 아래에서 어떤 일이 벌어지는지는 잘 모르겠습니다.

- 또 웹서버에서는 html파일 등을 정적으로 서비스할 수도 있지만 EJS나 Flask등을 사용하여 동적으로 서비스할 수도 있습니다. 구글 메인 페이지를 서비스할 때 이러한 server side rendering이 이루어지는지는 잘 모르겠습니다.
- 구글 서버에서는 Docker등 container를 사용하여 가상화를 하고 있고, 이를 통한 load balancing도 이루어지고 있습니다. 그러나 이 과정 역시 구체적으로 어떻게 동작하는지는 모릅니다. 다만 최신 Kubernetes는 Completely Fair Scheduler를 사용하여 스케줄링을 수행한다고 합니다.

결과적으로 이 데이터는 수신 과정의 정 반대 과정을 거쳐 사용자 컴퓨터로 돌아옵니다.

## 다시 네트워크에서

이때 유저가 public network에 바로 연결되어있다면 좋겠지만, 일반적으로는 private network에 연결되어있습니다. 그러므로 서버 측에서는 유저의 위치를 알지 못하고, gateway가 있는 router의 public address로 패킷을 전송합니다. 그러면 게이트웨이에 있는 Network Address Translation (NAT) Table에서 외부 포트에 해당되는 내부 포트로 패킷을 포워딩해줍니다.

## 다시 유저 프로세스에서

이제 유저는 전송 과정의 정 반대 과정을 거쳐 html파일을 받습니다. 이제 브라우저에서는 이 데이터를 파싱한 후 유저에게 렌더링해줍니다. 파싱 과정에서 다른 리소스를 요구하는 태그가 발견될 경우, 다시 이 모든 과정을 거쳐서 리소스를 로드한 후 DOM을 변경하고, 새로 렌더링합니다. 수행할 자바스크립트가 있으면 수행합니다. 이 과정은 물론 약간의 blocking이 있기는 하나, JavaScript에서 single thread로 동작합니다. 이를 위하여 event loop가 사용됩니다. (실제로는 file system이나 network등에서는 multithread 방식으로 동작하지만, 단일 스레드로 동작한다고 생각해도 됩니다.) Event loop는 간단하게는 call stack과 callback queue로 이루어지는데, 만약 DOM or Ajax등 비동기 작업이 필요할 경우 callback queue에 해당 작업을 push한 후 그냥 넘어갑니다. 이후 call stack이 모두 빌 경우 callback queue에서 하나를 꺼내어 수행합니다.

## 결과

이러한 과정을 거쳐서, 유저가 엔터 키를 누르면 브라우저에 구글 메인 화면이 표시됩니다.
